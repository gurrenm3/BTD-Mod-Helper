using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Assets.Scripts.Utils;
using BTD_Mod_Helper.Extensions;
using Il2CppSystem.Threading.Tasks;
using MelonLoader;
using UnhollowerRuntimeLib;
using Exception = System.Exception;
using Object = Il2CppSystem.Object;

namespace BTD_Mod_Helper.Api
{
    /// <summary>
    /// A class that can be generated by your mod in order to statically load a big complex Model object in your mod, like Ninja Kiwi does with the whole GameModel
    /// </summary>
    public abstract class ModByteLoader : ModContent
    {
        private static bool loadedAllBytes;

        private static Task currentLoadTask;

        /// <summary>
        /// Whether the Result has been Loaded yet
        /// </summary>
        public bool Loaded { get; private set; }

        /// <summary>
        /// The Task responsible for loading the bytes in the background
        /// </summary>
        protected Task LoadTask { get; private set; }

        /// <summary>
        /// The bytes that will be loaded from
        /// </summary>
        protected byte[] Bytes { get; private set; }

        /// <summary>
        /// The file name of the bytes file within your project.
        /// <br/>
        /// <b>Remember to add it as an embedded resource!</b>
        /// </summary>
        protected abstract string BytesFileName { get; }


        /// <inheritdoc />
        protected sealed override void Register()
        {
        }

        internal abstract void OnBytesLoaded();

        internal static void OnUpdate()
        {
            if (!loadedAllBytes && (currentLoadTask == null || currentLoadTask.IsCompleted))
            {
                if (GetContent<ModByteLoader>().FirstOrDefault(loader => !loader.Loaded) is ModByteLoader modByteLoader)
                {
                    currentLoadTask = modByteLoader.LoadTask = Task.Run(new Action(() =>
                    {
                        MelonLogger.Msg($"Beginning to load {modByteLoader.Name}");
                        modByteLoader.OnBytesLoaded();
                        modByteLoader.Loaded = true;
                        MelonLogger.Msg($"Finished loading {modByteLoader.Name}");
                    }));
                }
                else
                {
                    loadedAllBytes = true;
                }
            }
        }

        /// <summary>
        /// Set up the bytes when this is loaded
        /// </summary>
        /// <returns></returns>
        public sealed override IEnumerable<ModContent> Load()
        {
            var streamName = mod.Assembly.GetManifestResourceNames().FirstOrDefault(s => s.EndsWith(BytesFileName));

            if (streamName != null && mod.Assembly.GetManifestResourceStream(streamName) is Stream stream)
            {
                var memoryStream = new MemoryStream();
                stream.CopyTo(memoryStream);
                Bytes = memoryStream.ToArray();
            }
            else
            {
                MelonLogger.Warning($"Couldn't find bytes file {BytesFileName} in Assembly {mod.GetModName()}. " +
                                    "Did you forget to include it as an embedded resource?");
            }

            yield return this;
        }

        private static readonly string[] References =
        {
            "Assets.Scripts.Models.Towers.TargetType"
        };

        private static readonly string[] Structs =
        {
            "Assets.Scripts.Models.Map.AreaType",
            "Assets.Scripts.Simulation.SMath.Vector3"
        };

        private static readonly string[] Enums =
        {
            "Assets.Scripts.Models.Towers.TowerModel.TowerSize"
        };

        /// <summary>
        /// Generates a ModByteLoader class and corresponding .bytes file within the BloonsTD6 directory
        /// </summary>
        /// <param name="model">The model that you want to be able to be statically loaded from bytes</param>
        /// <param name="loaderFilePath">The absolute file path on your system where the .cs Loader file should end up</param>
        /// <param name="bytesFilePath">The absolute file path on your system where the bytes file should end up</param>
        /// <typeparam name="T"></typeparam>
        public static void Generate<T>(T model, string loaderFilePath, string bytesFilePath) where T : Object
        {
            var unconvertedLoader = $"{FileIOUtil.sandboxRoot}UnconvertedLoader.cs";

            var loaderName = loaderFilePath.Substring(loaderFilePath.LastIndexOf('\\') + 1).Split('.')[0];
            var bytesFileName = bytesFilePath.Substring(bytesFilePath.LastIndexOf('\\') + 1);

            var flatFileCodeGen = new FlatFileCodeGen();

            try
            {
                flatFileCodeGen.Generate(model, bytesFilePath, unconvertedLoader);
            }
            catch (Exception e)
            {
                MelonLogger.Error($"Failed to generate bytes {bytesFilePath}");
                MelonLogger.Error(e);
                return;
            }

            MelonLogger.Msg($"Generated bytes {bytesFilePath}");

            try
            {
                ConvertLoader<T>(unconvertedLoader, loaderFilePath, loaderName, bytesFileName);
            }
            catch (Exception e)
            {
                MelonLogger.Error($"Failed to generate ModByteLoader {loaderFilePath}");
                MelonLogger.Error(e);
                return;
            }

            MelonLogger.Msg($"Generated ModByteLoader {loaderFilePath}");

            File.Delete(unconvertedLoader);
        }

        /// <summary>
        /// Converts a generated Loader using normal System data structures to one that uses IL2Cpp ones
        /// </summary>
        /// <param name="unconvertedLoader">Absolute file path of the BTD6 generated loader .cs</param>
        /// <param name="convertedLoader"></param>
        /// <param name="className"></param>
        /// <param name="bytesFileName"></param>
        private static void ConvertLoader<T>(string unconvertedLoader, string convertedLoader, string className,
            string bytesFileName) where T : Object
        {
            using (var reader = new StreamReader(unconvertedLoader))
            {
                var loader = reader.ReadToEnd();

                loader = "using UnhollowerBaseLib;\n" +
                         "using UnhollowerRuntimeLib;\n" +
                         "using BTD_Mod_Helper.Extensions;\n" +
                         "using BTD_Mod_Helper.Api;\n" +
                         loader;
                loader = loader.Replace($"{Il2CppType.Of<T>().Name}Loader : IGameModelLoader",
                    $"{className} : {nameof(ModByteLoader)}<{Il2CppType.Of<T>().FullName}>");
                loader = loader.Replace("using System", "using Il2CppSystem");
                loader = loader.Replace("using Il2CppSystem.IO", "using System.IO");
                loader = Regex.Replace(loader, @"private void (.*)<T>\(\) {",
                    @"private void $1<T>() where T : Il2CppObjectBase {");

                loader = loader.Replace("samplesField.SetValue(v,(System.Single[]) m[br.ReadInt32()]);",
                    "v.samples = (System.Single[]) m[br.ReadInt32()];");

                loader = loader.Replace("T[]", "Il2CppReferenceArray<T>");
                loader = loader.Replace("new string[arrCount]", "new Il2CppStringArray(arrCount)");
                loader = loader.Replace("System.String[]", "Il2CppStringArray");
                loader = loader.Replace("System.Single[]", "Il2CppStructArray<float>");
                loader = loader.Replace("System.Int32[]", "Il2CppStructArray<int>");
                loader = loader.Replace("new int[arrCount]", "new Il2CppStructArray<int>(arrCount)");
                loader = loader.Replace("new float[arrCount]", "new Il2CppStructArray<float>(arrCount)");
                loader = loader.Replace("new T[br.ReadInt32()]", "new Il2CppReferenceArray<T>(br.ReadInt32())");
                loader = loader.Replace("(T)FormatterServices.GetUninitializedObject(t)",
                    "FormatterServices.GetUninitializedObject(t).Cast<T>()");
                loader = Regex.Replace(loader, @"typeof\(([A-Z].*)\)", @"Il2CppType.Of<$1>()");
                loader = loader.Replace(
                    "arr[j] = new Assets.Scripts.Models.Towers.TargetType(br.ReadString(), br.ReadBoolean())",
                    "arr[j] = new Assets.Scripts.Models.Towers.TargetType {id = br.ReadString(), isActionable = br.ReadBoolean()}");
                loader = loader.Replace(
                    "v.targetType = new Assets.Scripts.Models.Towers.TargetType(br.ReadString(), br.ReadBoolean());",
                    "v.targetType.id = br.ReadString();\n\t\t\tv.targetType.actionOnCreate = br.ReadBoolean();");

                loader = loader.Replace("\tpublic", "\tprotected override");
                loader = loader.Replace("object[] m;",
                    $"protected override string BytesFileName => \"{bytesFileName}\";\n\tobject[] m;");

                foreach (var reference in References)
                {
                    loader = loader.Replace($"{reference}[arrCount]", $"Il2CppReferenceArray<{reference}>(arrCount)");
                    loader = loader.Replace($"{reference}[]", $"Il2CppReferenceArray<{reference}>");
                }

                foreach (var strukt in Structs)
                {
                    loader = loader.Replace($"{strukt}[arrCount]", $"Il2CppStructArray<{strukt}>(arrCount)");
                    loader = loader.Replace($"{strukt}[]", $"Il2CppStructArray<{strukt}>");
                }

                foreach (var enuhm in Enums)
                {
                    loader = Regex.Replace(loader, $@"\({enuhm}\) \((br\.ReadInt32\(\))\)", @"$1");
                }

                loader = Regex.Replace(loader, @"SetValue\(v\,br\.ReadInt32\(\)\)",
                    @"SetValue(v,br.ReadInt32().ToIl2Cpp())");
                loader = Regex.Replace(loader, @"SetValue\(v\,br\.ReadSingle\(\)\)",
                    @"SetValue(v,br.ReadSingle().ToIl2Cpp())");
                loader = Regex.Replace(loader, @"SetValue\(v\,br\.ReadBoolean\(\)\)",
                    @"SetValue(v,br.ReadBoolean().ToIl2Cpp())");

                loader = Regex.Replace(loader, @"\(([A-Z].+)\[\]\)", @"(Il2CppReferenceArray<$1>)");

                using (var writer = new StreamWriter(convertedLoader))
                {
                    writer.Write(loader);
                }
            }
        }
    }

    public abstract class ModByteLoader<T> : ModByteLoader where T : Object
    {
        private T result;

        protected abstract T Load(byte[] bytes);

        internal sealed override void OnBytesLoaded()
        {
            result = Load(Bytes);
        }

        public T Load()
        {
            LoadTask.Wait(); // Just in case the loading hasn't completed yet
            return result;
        }
    }
}